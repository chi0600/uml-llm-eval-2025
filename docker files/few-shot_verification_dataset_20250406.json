[
    {
        "file_name": "GPT_contain_alt_v2.txt",
        "input": "# Requirements: Character Selection\n\n## Goal\nAllow a player to select a character in a game lobby. If the chosen character is locked, handle unlocking logic through in-game currency or a purchase flow. If the player cannot or chooses not to unlock, they must select a different character.\n\n## Actors\n- **Player (P)**: Chooses which character to play.\n- **Game Server (GS)**: Manages character data, checks if a character is locked, and initiates currency or purchase flows.\n- **Payment System (PS)**: Handles real-money transactions if the player opts to buy currency or unlock the character directly.\n\n## Preconditions\n- The player is authenticated and in the character selection lobby.\n- The game server has information about which characters are locked or unlocked for this player.\n- The player has some in-game currency balance, which might be insufficient.\n\n## Triggers\n- The player attempts to select a character.\n\n## Scenario\n1. The player chooses a character from the roster.\n2. The Game Server checks if the character is locked or unlocked.\n\n## Alternative Flows\n\n### Alternative Flow A: Character Unlocked\n- If the character is already unlocked, the server confirms the selection and the player proceeds.\n\n### Alternative Flow B: Character Locked\n1. The server checks if the player has enough in-game currency to unlock the character.\n2. **If sufficient currency is available:**\n   - The server asks the player to confirm spending the currency.\n   - If the player confirms, the character is unlocked and selected.\n   - If the player declines, the system prompts the player to either purchase currency or pick a different character.\n3. **If insufficient currency is available:**\n   - The system offers two choices:\n     - **Purchase Currency:** The server redirects to the Payment System to buy currency.\n       - If the purchase succeeds, the player can attempt to unlock the character again.\n       - If the purchase fails or the player cancels, the system prompts the player to pick a different character.\n     - **Pick a Different Character:** The player returns to the roster to choose another character.",
        "output": "@startuml\ntitle Character Selection\n\nactor \"Player\" as P\nparticipant \"Game Server\" as GS\nparticipant \"Payment System\" as PS\n\nP -> GS: Select Character\nactivate GS\nGS -> GS: Check if character is locked\n\nalt Character Unlocked\n  GS -> P: Confirm selection\nelse Character Locked\n  GS -> GS: Check player currency\n  alt Sufficient currency\n    GS -> P: Ask to spend currency\n    alt Player confirms spending\n      GS -> GS: Unlock character\n      GS -> P: Confirm selection\n    else Player declines spending\n      GS -> P: Prompt to purchase currency or pick different character\n    end\n  else Insufficient currency\n    GS -> P: Offer to purchase currency or pick different character\n    alt Player chooses to purchase\n      P -> PS: Buy currency\n      activate PS\n      alt Purchase successful\n        PS --> P: Confirm purchase\n        PS --> GS: Update currency balance\n        deactivate PS\n        GS -> P: Attempt character unlock again\n      else Purchase fails or canceled\n        PS --> P: Purchase failed/canceled\n        deactivate PS\n        GS -> P: Pick different character\n      end\n    else Player picks different character\n      GS -> P: Return to character roster\n    end\n  end\nend\n\ndeactivate GS\n@enduml"
    },
    {
        "file_name": "GPT_contain_alt_v3.txt",
        "input": "# Requirements: Patient Appointment Scheduling\n\n## Goal\nAllow a patient to schedule an appointment with a doctor. If the desired time slot is unavailable, offer alternative time slots and handle the patient’s decision to accept an alternative, reschedule, or cancel the request.\n\n## Actors\n- **Patient (P)**: Requests an appointment and chooses from alternatives.\n- **Appointment System (AS)**: Checks the doctor’s schedule and manages the appointment process.\n- **Doctor’s Schedule (DS)**: Provides availability for appointments.\n\n## Preconditions\n- The patient is logged in.\n- The Appointment System is operational.\n- The doctor’s schedule is accessible.\n\n## Triggers\n- The patient submits an appointment request for a desired time.\n\n## Scenario\n1. The patient requests an appointment at a desired time.\n2. The Appointment System checks the Doctor’s Schedule for availability.\n\n## Alternative Flows\n\n### Alternative Flow 1: Slot Available\n- If the slot is available, the Appointment System confirms the appointment.\n\n### Alternative Flow 2: Slot Unavailable\n- If the slot is not available, the system offers alternative time slots.\n- If the patient accepts an alternative slot, the system confirms the appointment.\n- If the patient rejects the alternatives, the system asks if they want to reschedule or cancel the request.\n- Depending on the patient’s decision, the system either restarts the scheduling process (reschedule) or cancels the appointment request.",
        "output": "@startuml\ntitle Patient Appointment Scheduling\n\nactor \"Patient\" as P\nparticipant \"Appointment System\" as AS\nparticipant \"Doctor's Schedule\" as DS\n\nP -> AS: Request Appointment (desired time)\nactivate AS\nAS -> DS: Check Availability for desired time\nactivate DS\n\nalt Slot Available\n    DS --> AS: Slot Confirmed\n    deactivate DS\n    AS -> P: Confirm Appointment at desired time\nelse Slot Not Available\n    DS --> AS: Slot Unavailable\n    deactivate DS\n    AS -> P: Offer alternative slots\n\n    alt Patient Accepts Alternative\n        P -> AS: Accept alternative slot\n        AS -> DS: Book alternative slot\n        DS --> AS: Alternative slot confirmed\n        AS -> P: Confirm Appointment (alternative slot)\n    else Patient Rejects Alternatives\n        P -> AS: Reject alternative slots\n        AS -> P: Ask to Reschedule or Cancel\n\n        alt Patient chooses Reschedule\n            P -> AS: Provide new desired time\n            AS -> DS: Check Availability for new time\n            note right\n              The scheduling process repeats\n              with the new desired time\n            end note\n        else Patient cancels request\n            P -> AS: Cancel Appointment Request\n            AS -> P: Confirm Cancellation\n        end\n    end\nend\n\ndeactivate AS\n@enduml"
    },
    {
        "file_name": "GPT_contain_alt_v4.txt",
        "input": "# Requirements: Industrial Robot Safety Monitoring with Alternative Flows\n\n## Goal\nEnsure safe operation of an industrial robot by continuously monitoring its environment. When an obstacle is detected, the system takes appropriate actions based on the risk assessment—either performing an evasive maneuver (if the risk is low) or stopping the robot and alerting a supervisor (if the risk is high).\n\n## Actors\n- **Industrial Robot Controller (IRC)**: Receives sensor data and manages robot operations.\n- **Safety Sensor System (SSS)**: Continuously monitors the robot’s environment for obstacles.\n- **Supervisor Notification System (SNS)**: Notifies the supervisor in case of a high-risk safety event.\n\n## Preconditions\n- The robot is actively operating in a manufacturing cell.\n- The safety sensors are active and calibrated.\n\n## Triggers\n- The Safety Sensor System continuously sends sensor data to the Industrial Robot Controller.\n\n## Scenario\n1. The Safety Sensor System continuously monitors for obstacles and sends sensor data to the Industrial Robot Controller.\n\n2a. **Alternative Flow A (No Obstacle)**  \n   - If no obstacle is detected, the IRC continues normal operation and logs that everything is normal.\n\n2b. **Alternative Flow B (Obstacle Detected)**  \n   - The IRC stops the robot immediately.  \n   - Then, it evaluates the risk level:\n     - **If the risk is low:** The IRC performs an evasive maneuver and logs that the maneuver was executed.\n     - **If the risk is high:** The IRC alerts the Supervisor Notification System to inform the supervisor and logs an emergency stop.\n\n3. The monitoring cycle repeats continuously.",
        "output": "@startuml\ntitle Industrial Robot Safety Monitoring\n\nparticipant \"Industrial Robot Controller\" as IRC\nparticipant \"Safety Sensor System\" as SSS\nparticipant \"Supervisor Notification System\" as SNS\n\nloop Continuous Safety Monitoring\n  SSS -> IRC: Send sensor data\n  activate IRC\n  alt No Obstacle Detected\n    IRC -> IRC: Continue normal operation\n    IRC -> IRC: Log \"Operation normal\"\n  else Obstacle Detected\n    IRC -> IRC: Stop Robot Operation\n    alt Low Risk\n      IRC -> IRC: Execute evasive maneuver\n      IRC -> IRC: Log \"Evasive maneuver executed\"\n    else High Risk\n      IRC -> SNS: Alert Supervisor \"High risk obstacle detected\"\n      activate SNS\n      SNS --> IRC: Acknowledge Alert\n      deactivate SNS\n      IRC -> IRC: Log \"Emergency stop executed\"\n    end\n  end\n  deactivate IRC\nend\n@enduml"
    },
    {
        "file_name": "GPT_contain_alt_v5.txt",
        "input": "# Requirements: Network Connection Setup\n\n## Goal\nAllow a client to establish a network connection to a server. The client tries the primary route first, and if that fails, it sequentially attempts secondary and tertiary routes until the connection is established or all options are exhausted.\n\n## Actors\n- **Client (C):** Initiates the connection request.\n- **Network Router (NR):** Routes the connection request along various paths.\n- **Server (S):** The destination able to accept connections.\n\n## Preconditions\n- Multiple routing paths exist in the network (primary, secondary, tertiary).\n- The server is available to accept connections.\n\n## Triggers\n- The client initiates a connection request.\n\n## Scenario\n1. The client sends a connection request to the network router.\n2. The network router first attempts to route the request via the primary path.\n\n### Alternative Flow A (Primary Path Successful)\n1. The primary path works.\n2. The server establishes the connection.\n3. The router notifies the client.\n\n### Alternative Flow B (Primary Path Fails)\n1. The router attempts the secondary path.\n2. If successful, the server establishes the connection and the router confirms it to the client.\n3. If the secondary path also fails, the router attempts the tertiary route.\n4. If the tertiary route is successful, the connection is established.\n5. If not, the router notifies the client of the failure.",
        "output": "@startuml\ntitle Network Connection Setup\n\nactor \"Client\" as C\nparticipant \"Network Router\" as NR\nparticipant \"Server\" as S\n\nC -> NR: Initiate Connection Request\nactivate NR\nNR -> NR: Attempt Primary Path\nalt Primary Path Successful\n    NR -> S: Forward Request via Primary\n    activate S\n    S --> NR: Connection Established\n    deactivate S\n    NR -> C: Confirm Connection via Primary\nelse Primary Path Fails\n    NR -> NR: Attempt Secondary Path\n    alt Secondary Path Successful\n        NR -> S: Forward Request via Secondary\n        activate S\n        S --> NR: Connection Established\n        deactivate S\n        NR -> C: Confirm Connection via Secondary\n    else Secondary Path Fails\n        NR -> NR: Attempt Tertiary Path\n        alt Tertiary Path Successful\n            NR -> S: Forward Request via Tertiary\n            activate S\n            S --> NR: Connection Established\n            deactivate S\n            NR -> C: Confirm Connection via Tertiary\n        else Tertiary Path Fails\n            NR -> C: Notify Connection Failed\n        end\n    end\nend\ndeactivate NR\n@enduml"
    },
    {
        "file_name": "GPT_contain_alt_v6.txt",
        "input": "# Requirements: Smart Demand Response\n\n## Goal\nManage peak demand by automatically or manually reducing consumer energy load when the grid is under stress.\n\n## Actors\n- **Smart Grid Controller (SGC)**: Monitors grid load and initiates demand response.\n- **Home Energy Management System (HEMS)**: Automatically adjusts energy usage for enrolled consumers.\n- **Notification Service (NS)**: Sends messages to consumers for manual load reduction.\n- **Consumer**: May receive a notification if not enrolled in automated demand response.\n\n## Preconditions\n- The grid is continuously monitored for load conditions.\n- Consumers may or may not be enrolled in an automated demand response program.\n- HEMS and NS are operational and connected to the SGC.\n\n## Triggers\n- Grid load exceeds a predefined threshold.\n\n## Basic Scenario (Consumer Enrolled) \n1. The SGC monitors grid load continuously.  \n2. When grid load is high, the SGC initiates a demand response event.  \n3. The SGC checks if the consumer’s HEMS is enrolled in the automated demand response program.  \n4. The HEMS confirms enrollment.  \n5. The SGC instructs the HEMS to adjust load settings (e.g., lower the thermostat, postpone water heating).  \n6. The HEMS adjusts the load accordingly.  \n7. The SGC logs the demand response event.\n\n## Alternative Flow A (Consumer Not Enrolled)\n1. Same as Basic Scenario step 1. \n2. Same as Basic Scenario step 2.\n3. Same as Basic Scenario step 3. \n4. The SGC sends a notification via the Notification Service.  \n5. The consumer receives a message asking them to manually reduce energy consumption.  \n6. The SGC logs the demand response event.",
        "output": "@startuml\ntitle Smart Demand Response with Alternative Flows\n\nparticipant \"Smart Grid Controller\" as SGC\nparticipant \"Home Energy Management System\" as HEMS\nparticipant \"Notification Service\" as NS\nactor \"Consumer\" as C\n\nSGC -> SGC: Monitor Grid Load\nactivate SGC\nalt Grid Load Normal\n  SGC -> SGC: Continue Normal Operation\nelse Grid Load High\n  SGC -> SGC: Initiate Demand Response\n  SGC -> HEMS: Check Enrollment in Automated DR\n  activate HEMS\n  alt Consumer Enrolled in Automated DR\n    HEMS --> SGC: Confirm Enrollment\n    SGC -> HEMS: Adjust Load Settings (e.g., Lower Thermostat)\n    HEMS --> SGC: Load Adjusted\n  else Consumer Not Enrolled\n    HEMS --> SGC: Not Enrolled\n    deactivate HEMS\n    SGC -> NS: Send Notification for Manual Load Reduction\n    activate NS\n    NS --> C: Notify \"Please reduce energy consumption\"\n    deactivate NS\n  end\nend\nSGC -> SGC: Log Demand Response Event\ndeactivate SGC\n@enduml"
    },
    {
        "file_name": "GPT_contain_interaction_v2.txt",
        "input": "# Requirements: Device Registration\n\n## Goal\nAllow a new network device to register and activate on the telecom network by a security authentication process.\n\n## Actors\n- **New Device (ND):** Initiates the registration request.\n- **Network Management System (NMS):** Processes registration and retrieves device configuration.\n- **Fraud Detection Service:** Evaluates the payment details for potential fraud.\n- **Configuration Server (CS):** Provides device-specific configuration data.\n\n## Preconditions\n- The new device is not yet registered on the network.\n- The common security authentication process is available for reuse.\n\n## Triggers\n- The new device sends a registration request.\n\n## Scenario\n1. The new device sends a registration request to the Network Management System.\n2. The NMS uses a security authentication process to verify the device credentials (see **Common Security Authentication Process**).\n3. Upon successful authentication, the NMS contacts the Configuration Server to retrieve configuration data for the device.\n4. The NMS confirms the registration and activation to the device, along with its configuration.",
        "output": "@startuml\ntitle Device Registration\n\nactor \"New Device\" as ND\nparticipant \"Network Management System\" as NMS\nparticipant \"Security Authentication Service\" as SAS\nparticipant \"Configuration Server\" as CS\n\nND -> NMS: Initiate Registration Request\nactivate NMS\n\n' Reuse the security authentication process:\nref over ND, SAS\nSecurity Authentication Process\nend ref\n\nNMS -> CS: Retrieve Configuration Data\nactivate CS\nCS --> NMS: Return Configuration Data\ndeactivate CS\n\nNMS -> ND: Confirm Registration and Provide Configuration\ndeactivate NMS\n@enduml"
    },
    {
        "file_name": "GPT_contain_interaction_v3.txt",
        "input": "# Requirements: Digital Payment Processing with Fraud Detection\n\n## Goal\nAllow a customer to make a digital payment while ensuring security by fraud detection process.\n\n## Actors\n- **Customer:** Initiates the payment request.\n- **Payment Gateway:** Processes the payment and coordinates the fraud check.\n- **Fraud Detection Service:** Evaluates the payment details for potential fraud.\n- **Merchant System:** Processes the actual payment once the fraud check is passed.\n\n## Preconditions\n- The customer has valid payment details.\n- The Payment Gateway is integrated with a common fraud detection process.\n\n## Triggers\n- The customer initiates a payment request.\n\n## Scenario\n1. The customer initiates a payment request via the Payment Gateway.  \n2. The Payment Gateway uses the fraud detection process to validate the payment details(refer to Fraud Detection Process).\n3. Upon passing the fraud check, the Payment Gateway forwards the request to the Merchant System to process the payment.  \n4. The Merchant System processes the payment and confirms the transaction.  \n5. Finally, the Payment Gateway confirms the successful payment back to the customer.",
        "output": "@startuml\ntitle Digital Payment Processing with Fraud Detection\n\nactor \"Customer\" as C\nparticipant \"Payment Gateway\" as PG\nparticipant \"Fraud Detection Service\" as FDS\nparticipant \"Merchant System\" as MS\n\nC -> PG: Initiate Payment Request\nactivate PG\n\n' Reuse the common fraud detection process:\nref over PG, FDS\n  Fraud Detection Process\nend ref\n\nPG -> MS: Process Payment\nactivate MS\nMS --> PG: Payment Processed\ndeactivate MS\n\nPG -> C: Confirm Payment\ndeactivate PG\n@enduml"
    },
    {
        "file_name": "GPT_contain_interaction_v4.txt",
        "input": "# Requirements: Course Enrollment with Prerequisite Verification\n\n## Goal\nAllow a student to enroll in a course after verifying that they have completed the necessary prerequisite courses using a verification process.\n\n## Actors\n- **Student:** Submits the course enrollment request.\n- **Enrollment System:** Manages course enrollment requests and routes them for prerequisite verification.\n- **Academic Records System:** Checks the student's completed courses to determine if the prerequisites are met.\n\n## Preconditions\n- The student is registered on the e-learning platform.\n- Academic records are maintained and accessible in the Academic Records System.\n\n## Triggers\n- The student submits an enrollment request for a specific course.\n\n## Scenario\n1. The student submits an enrollment request via the Enrollment System.\n2. The Enrollment System reuses the prerequisite verification process to check if the student has met the prerequisites for the desired course(refer to Prerequisite Verification Process).\n   - **Alternative Flow A (Prerequisites Met):**\n     - If the prerequisites are met, the Enrollment System confirms the enrollment.\n   - **Alternative Flow B (Prerequisites Not Met):**\n     - If the prerequisites are not met, the Enrollment System notifies the student that enrollment cannot proceed and provides guidance (e.g., suggesting the courses needed to fulfill the prerequisites).",
        "output": "@startuml\ntitle Course Enrollment with Prerequisite Verification\n\nactor \"Student\" as S\nparticipant \"Enrollment System\" as ES\nparticipant \"Academic Records System\" as ARS\n\nS -> ES: Submit Enrollment Request (Course X)\nactivate ES\n\n' Reuse the common prerequisite verification process:\nref over S, ARS \n    Prerequisite Verification Process\nend ref\n\nalt Prerequisites met\n    ES -> S: Confirm Enrollment in Course X\nelse Prerequisites not met\n    ES -> S: Notify \"Enrollment failed: prerequisites not met\"\nend\n\ndeactivate ES\n@enduml"
    },
    {
        "file_name": "GPT_contain_interaction_v5.txt",
        "input": "# Requirements: Smart Parking Reservation with Availability Check\n\n## Goal\nAllow a driver to reserve a parking spot in a smart city environment by reusing a parking availability check process.\n\n## Actors\n- **Driver:** Initiates the parking reservation request.\n- **Smart Parking Portal (SPP):** Manages the reservation process.\n- **Parking Availability Service (PAS):** Checks for available parking spots.\n\n## Preconditions\n- The driver has an account and selects a parking location.\n- The system maintains real-time data on parking availability.\n\n## Triggers\n- The driver submits a reservation request through the portal.\n\n## Scenario\n1. The driver requests a parking reservation for a specific location.\n2. The Smart Parking Portal invokes the parking availability check process to determine if a parking spot is available.\n\n### Alternative Flow\n- **If a spot is available:** The portal confirms the reservation to the driver.\n- **If no spot is available:** The portal notifies the driver and suggests trying alternate locations.",
        "output": "@startuml\ntitle Smart Parking Reservation with Availability Check\n\nactor \"Driver\" as D\nparticipant \"Smart Parking Portal\" as SPP\nparticipant \"Parking Availability Service\" as PAS\n\nD -> SPP: Request Parking Reservation (Location X)\nactivate SPP\n\n' Use the parking availability check process:\nref over SPP, PAS\n  Parking Availability Check Process\nend ref\n\nalt Parking Available\n  SPP -> D: Confirm Reservation for Location X\nelse Parking Not Available\n  SPP -> D: Notify \"Parking not available. Try alternate locations.\"\nend\n\ndeactivate SPP\n@enduml"
    },
    {
        "file_name": "GPT_contain_interaction_v6.txt",
        "input": "# Requirements: Vehicle Diagnostic\n\n## Goal\nAllow the vehicle to perform a self-diagnostic check before running a complete self-test routine. If any faults are detected, the system automatically schedules maintenance; otherwise, it confirms that the vehicle is operating normally.\n\n## Actors\n- **Driver (D)**: Initiates the self-diagnostic process.\n- **Vehicle Diagnostic System (VDS)**: Coordinates the self-test and processes results.\n- **Self-Test Service (STS)**: Provides a reusable self-test routine that checks engine, brakes, sensors, etc.\n- **Maintenance Scheduling System (MSS)**: Schedules a service appointment if a fault is detected.\n\n## Preconditions\n- The vehicle is powered on and ready to perform diagnostics.\n- The vehicle is available and integrated with the VDS.\n\n## Triggers\n- The driver initiates the self-diagnostic process.\n\n## Basic Scenario - Fault Detected\n1. The driver initiates the self-diagnostic process.\n2. The VDS uses the self-test routine to check all critical subsystems (refer to Self-Test Routine).\n3. The Self-Test Service (STS) returns the test results.\n4. The VDS contacts the MSS to schedule maintenance and notifies the driver.\n\n## Alternative Flow A - No Fault Detected\n1. Same as Basic Scenario step 1. \n2. Same as Basic Scenario step 2.\n3. Same as Basic Scenario step 3.\n4. If no faults are detected, the VDS informs the driver that all systems are normal.",
        "output": "@startuml\ntitle Vehicle Diagnostic\n\nactor \"Driver\" as D\nparticipant \"Vehicle Diagnostic System\" as VDS\nparticipant \"Self-Test Service\" as STS\nparticipant \"Maintenance Scheduling System\" as MSS\n\nD -> VDS: Initiate Self-Diagnostic Process\nactivate VDS\n\n' Reuse the common self-test routine:\nref over VDS, STS \n    Self-Test Routine\nend ref\n\nalt Fault Detected\n    VDS -> MSS: Schedule Maintenance Appointment\n    activate MSS\n    MSS --> VDS: Appointment Confirmed\n    deactivate MSS\n    VDS -> D: Notify \"Fault Detected; Maintenance Scheduled\"\nelse No Faults\n    VDS -> D: Notify \"All Systems Normal\"\nend\n\ndeactivate VDS\n@enduml"
    },
    {
        "file_name": "GPT_contain_loop_v2.txt",
        "input": "# Requirements: Continuous Network Health Monitoring\n\n## Goal\nContinuously monitor the network status and send alerts if any network node becomes unresponsive, repeating the check every minute until the node is restored.\n\n## Actors\n- **Network Monitoring System (NMS)**: Periodically pings network nodes.\n- **Alerting Service (AS)**: Sends alerts when a node is down.\n- **Network Node**: The monitored element in the network.\n\n## Preconditions\n- The monitoring system is configured with the list of network nodes.\n- Network nodes are expected to be operational under normal conditions.\n\n## Triggers\n- The monitoring system initiates a periodic check (every minute) to verify the status of each network node.\n\n## Scenario\n1. The NMS pings a Network Node.\n2. If the node responds, it sends back a “Pong” and the system logs the status.\n3. If the node does not respond, the NMS triggers the Alerting Service to send an alert indicating that the node is down.\n4. The NMS continues to ping the node every minute until it receives a response.\n5. Once the node is restored, the system logs the restoration event and stops sending alerts for that node.",
        "output": "@startuml\ntitle Continuous Network Health Monitoring (With Restoration Logic and Activation)\n\nactor \"Network Monitoring System\" as NMS\nparticipant \"Alerting Service\" as AS\nparticipant \"Network Node\" as Node\n\nloop Check Node Status Every Minute\n  NMS -> Node: Ping\n  activate Node\n  alt Node is responsive\n    Node --> NMS: Pong (Node OK)\n    NMS -> NMS: Log \"Node is up\"\n  else Node is unresponsive and was previously up\n    Node --> NMS: No Response\n    NMS -> AS: Send Alert: \"Node Down\"\n    NMS -> NMS: Mark node as down\n  else Node remains unresponsive (already marked down)\n    Node --> NMS: Still no response\n    ' No new alert is sent because the node is already marked down\n  else Node recovers (was marked down)\n    Node --> NMS: Pong (Node OK)\n    deactivate Node\n    NMS -> NMS: Mark node as up\n    NMS -> NMS: Log \"Node restored\"\n  end\nend\n@enduml"
    },
    {
        "file_name": "GPT_contain_loop_v3.txt",
        "input": "# Requirements: Continuous Patient Vital Signs Monitoring\n\n## Goal\nContinuously monitor a patient's vital signs and send alerts if any measurements are abnormal. The system repeats the check every 5 minutes until the patient’s vitals return to normal.\n\n## Actors\n- **Patient**: The individual being monitored.\n- **Vital Signs Monitoring System (VSMS)**: Periodically measures the patient’s vital signs (e.g., heart rate, blood pressure, oxygen saturation).\n- **Alerting Service (AS)**: Sends alerts when abnormal vital signs are detected.\n- **Doctor**: Receives notifications about the patient’s condition.\n\n## Preconditions\n- The patient is admitted to the intensive care unit (ICU).\n- The VSMS is configured and actively monitoring the patient.\n- Vital sign thresholds for normal versus abnormal conditions are predefined.\n\n## Triggers\n- The monitoring system initiates a periodic check every 5 minutes.\n\n## Scenario\n1. The VSMS measures the patient’s vital signs.\n2. If all vital signs are within normal ranges, the system logs that the patient is stable and stops further alerting (or optionally continues checking without sending additional alerts).\n3. If any vital sign is abnormal, the system sends an alert to the Alerting Service, which notifies the Doctor.\n4. The VSMS continues to check the patient’s vitals every 5 minutes until the measurements return to normal, at which point it logs the restoration of normal status.",
        "output": "@startuml\ntitle Continuous Patient Vital Signs Monitoring (with Patient Data in Loop)\n\nactor \"Patient\" as P\nparticipant \"Vital Signs Monitoring System\" as VSMS\nparticipant \"Alerting Service\" as AS\nparticipant \"Doctor\" as D\n\nloop Every 5 minutes\n  P --> VSMS: Provide Vital Signs Data\n  activate VSMS\n  VSMS -> VSMS: Measure vital signs\n  alt Vitals are normal\n    VSMS -> VSMS: Log \"Patient stable\"\n  else Vitals are abnormal\n    VSMS -> AS: Send Alert \"Patient unstable\"\n    activate AS\n    AS -> D: Notify Doctor\n    deactivate AS\n    VSMS -> VSMS: Log \"Alert sent\"\n  end\n  deactivate VSMS\nend\n@enduml"
    },
    {
        "file_name": "GPT_contain_loop_v4.txt",
        "input": "# Requirements: Multiplayer Matchmaking with Continuous Check\n\n## Goal\nAllow a player to join a match by continuously checking the matchmaking queue every 10 seconds until the required number of players is reached, at which point the match is started.\n\n## Actors\n- **Player**: Initiates the matchmaking request.\n- **Game Server**: Manages the matchmaking queue and checks the number of players.\n- **Matchmaker**: Starts the match when enough players are available.\n\n## Preconditions\n- The player is in the matchmaking queue.\n- The Game Server is configured to monitor the queue continuously.\n- A minimum number of players (e.g., 4) is required to start a match.\n\n## Triggers\n- The player requests to join a match.\n\n## Scenario\n1. The Player requests matchmaking from the Game Server.\n2. The Game Server adds the player (and possibly others) to the matchmaking queue.\n3. The Game Server checks the queue every 10 seconds:\n   - If the queue size is less than the required number of players, the server waits for additional players.\n   - If the queue size meets or exceeds the requirement, the Matchmaker is invoked to start the match, and the loop is exited.\n4. Once a match is started, the Game Server notifies the Player that the match has begun.",
        "output": "@startuml\ntitle Multiplayer Matchmaking with Continuous Check\n\nactor \"Player\" as P\nparticipant \"Game Server\" as GS\nparticipant \"Matchmaker\" as M\n\nP -> GS: Request Matchmaking\nactivate GS\nGS -> GS: Add player to queue\n\nloop Every 10 seconds\n  GS -> GS: Evaluate queue size\n  GS -> GS: Wait for additional players\n  break Queue size >= Required Players\n    GS -> M: Start Match\n  end\nend\n\nGS -> P: Notify Match Started\ndeactivate GS\n@enduml"
    },
    {
        "file_name": "GPT_contain_loop_v5.txt",
        "input": "# Requirements: Continuous Machine Temperature Monitoring in a Smart Factory\n\n## Goal\nContinuously monitor the temperature of a critical machine and, if the temperature is too high, automatically increase cooling and notify the maintenance team until the temperature returns to a normal level.\n\n## Actors\n- **Factory Control System (FCS)**: Monitors the machine’s temperature every minute.\n- **Cooling System (CS)**: Adjusts cooling based on commands from the FCS.\n- **Maintenance Team (MT)**: Receives alerts when the temperature is high.\n\n## Preconditions\n- The machine is operational.\n- The temperature sensor is functioning correctly.\n\n## Triggers\n- The FCS initiates a temperature check every minute.\n\n## Scenario\n1. Every minute, the FCS measures the machine’s temperature.\n2. If the temperature is within the normal range, the FCS logs “Temperature normal.”\n3. If the temperature exceeds the threshold:\n   - The FCS sends a command to the Cooling System to increase cooling.\n   - The FCS alerts the Maintenance Team.\n   - The system logs “Alert sent.”\n4. The cycle repeats continuously.",
        "output": "@startuml\ntitle Continuous Machine Temperature Monitoring in a Smart Factory\n\nparticipant \"Factory Control System\" as FCS\nparticipant \"Cooling System\" as CS\nparticipant \"Maintenance Team\" as MT\n\nloop Every 1 minute\n  activate FCS\n  FCS -> FCS: Measure Machine Temperature\n  alt Temperature is normal\n    FCS -> FCS: Log \"Temperature normal\"\n  else Temperature is high\n    FCS -> CS: Increase Cooling\n    activate CS\n    CS --> FCS: Cooling activated\n    deactivate CS\n    FCS -> MT: Send Alert \"High Temperature\"\n    FCS -> FCS: Log \"Alert sent\"\n  end\n  deactivate FCS\nend\n@enduml"
    },
    {
        "file_name": "GPT_contain_loop_v6.txt",
        "input": "# Requirements: Interceptor Guidance Update in Missile Defense\n\n## Goal\nAfter launching an interceptor missile, continuously update its flight path based on real‑time target data until the missile successfully intercepts the incoming threat or the interceptor fails.\n\n## Actors\n- **Ground Command Center (GCC)**: Initiates the launch and sends continuous guidance updates.\n- **Interceptor Missile (IM)**: Receives guidance updates and adjusts its course.\n- **Target Radar System (TRS)**: Tracks the incoming threat and provides updated target coordinates.\n\n## Preconditions\n- An interceptor missile has been launched in response to an incoming threat.\n- The Target Radar System is actively tracking the threat and providing updated coordinates.\n\n## Triggers\n- The interceptor missile enters flight mode and awaits continuous guidance updates.\n\n## Scenario\n1. The GCC launches an interceptor missile.\n2. The interceptor missile enters flight mode.\n3. Every few seconds the Target Radar System sends updated target coordinates to the GCC.\n4. The GCC sends guidance updates to the interceptor missile.\n5. If the interceptor missile successfully intercepts the target, it sends a confirmation to the GCC and the loop is exited.\n6. Otherwise, the interceptor missile adjusts its course according to the received guidance, and the loop continues until the target is intercepted or the missile fails.",
        "output": "@startuml\ntitle Interceptor Guidance Update in Missile Defense\n\nactor \"Ground Command Center\" as GCC\nparticipant \"Interceptor Missile\" as IM\nparticipant \"Target Radar System\" as TRS\n\nGCC -> IM: Launch Interceptor Missile\nactivate IM\nIM -> IM: Enter Flight Mode\n\nloop Every 5 seconds until target intercepted\n  TRS -> GCC: Provide Updated Target Coordinates\n  GCC -> IM: Send Guidance Update\n  IM -> IM: Adjust Course Based on Guidance\n  break Target Intercepted\n    IM --> GCC: Confirmation of Interception\n  end\nend\n\nGCC -> GCC: Log Interception Event\nIM -> GCC: Final Status Report\ndeactivate IM\n@enduml"
    },
    {
        "file_name": "GPT_contain_opt_v2.txt",
        "input": "# Requirements: SMS Sending\n\n## Goal\nAllow a customer to send an SMS and, if requested, receive a delivery report confirming the message’s status.\n\n## Actors\n- **Customer (C)**: Sends an SMS message, optionally selecting a delivery report.\n- **Telecom Messaging System (TMS)**: Processes SMS messages and manages optional interactions.\n- **SMS Gateway (SG)**: Delivers the SMS and, if requested, provides a delivery report.\n\n## Preconditions\n- The customer has a valid account and is authorized to send SMS.\n- The Telecom Messaging System and SMS Gateway are operational.\n- The customer’s SMS request may include an option to receive a delivery report.\n\n## Triggers\n- The customer submits an SMS message.\n\n## Scenario\n1. The customer sends an SMS message to the Telecom Messaging System (TMS).\n2. The TMS forwards the SMS to the SMS Gateway (SG) for delivery.\n3. The SG processes the delivery and returns a confirmation to the TMS.\n4. The TMS notifies the customer that the SMS was delivered.\n5. If the customer requested a delivery report:\n   - The TMS requests the delivery report from the SG.\n   - The SG provides the delivery report to the TMS.\n   - The TMS sends the delivery report to the customer.",
        "output": "@startuml\ntitle SMS Sending\n\nactor \"Customer\" as C\nparticipant \"Telecom Messaging System\" as TMS\nparticipant \"SMS Gateway\" as SG\n\nC -> TMS: Send SMS Message (with/without delivery report)\nactivate TMS\nTMS -> SG: Forward SMS Message\nactivate SG\nSG --> TMS: SMS Delivered Confirmation\ndeactivate SG\nTMS -> C: Notify SMS Delivered\n\nopt Delivery Report Requested\n  TMS -> SG: Request Delivery Report\n  activate SG\n  SG --> TMS: Delivery Report Received\n  deactivate SG\n  TMS -> C: Send Delivery Report\nend\ndeactivate TMS\n@enduml"
    },
    {
        "file_name": "GPT_contain_opt_v3.txt",
        "input": "# Requirements: Vehicle Maintenance Alert\n\n## Goal\nAlert the driver when a maintenance issue is detected and, if enabled, perform remote diagnostics to help determine the cause of the problem before scheduling a service appointment.\n\n## Actors\n- **Driver**: Receives maintenance alerts and diagnostic results.\n- **Vehicle Control Unit (VCU)**: Monitors vehicle health and detects maintenance issues.\n- **Remote Diagnostics System (RDS)**: Optionally analyzes diagnostic data from the vehicle.\n- **Service Center (SC)**: Receives diagnostic data for further evaluation if needed.\n\n## Preconditions\n- The vehicle is operational and equipped with sensors that can detect maintenance issues.\n- The remote diagnostics feature is available and may be enabled by the driver.\n\n## Triggers\n- The VCU detects a maintenance issue (e.g., low oil pressure).\n\n## Scenario\n1. The VCU detects a maintenance issue and sends a maintenance alert to the driver.\n2. If remote diagnostics is enabled, the VCU sends diagnostic data to the Remote Diagnostics System:\n   - The VCU sends diagnostic data to the Remote Diagnostics System (RDS).\n   - The RDS forwards the data to the Service Center (SC) and receives analysis results.\n   - The RDS returns the diagnostic results to the VCU, which then notifies the driver of these results.\n3. The VCU advises the driver to schedule a service appointment.",
        "output": "@startuml\ntitle Vehicle Maintenance Alert\n\nactor \"Driver\" as D\nparticipant \"Vehicle Control Unit\" as VCU\nparticipant \"Remote Diagnostics System\" as RDS\nparticipant \"Service Center\" as SC\n\nVCU -> D: Send Maintenance Alert (Issue Detected)\nactivate VCU\n' Optional interaction for remote diagnostics:\nopt Remote Diagnostics Enabled\n    VCU -> RDS: Send Diagnostic Data\n    activate RDS\n    RDS -> SC: Forward Diagnostic Data\n    activate SC\n    SC --> RDS: Diagnostic Analysis Results\n    deactivate SC\n    RDS --> VCU: Return Diagnostic Results\n    deactivate RDS\n    VCU -> D: Notify Diagnostic Results\nend\nVCU -> D: Advise Service Appointment\ndeactivate VCU\n@enduml"
    },
    {
        "file_name": "GPT_contain_opt_v4.txt",
        "input": "# Requirements: Loan Application Processing\n\n## Goal\nProcess a loan application and decide on approval based on credit and income verification. For high-value loans, an income verification is performed to ensure the applicant’s capacity to repay.\n\n## Actors\n- **Customer (C)**: Submits the loan application.\n- **Loan Processing System (LPS)**: Evaluates the application details and makes the approval decision.\n- **Income Verification Service (IVS)**: Optionally verifies the applicant’s income if the loan amount is high.\n- **Credit Bureau (CB)**: Provides credit check information.\n\n## Preconditions\n- The customer has submitted a complete loan application.\n- The Loan Processing System is integrated with the Credit Bureau and, optionally, with the Income Verification Service.\n\n## Triggers\n- The customer submits a loan application.\n\n## Scenario\n1. The customer submits a loan application to the Loan Processing System.\n2. The LPS validates the application details and requests a credit check from the Credit Bureau.\n3. The Credit Bureau returns the applicant’s credit score and report.\n4. If the loan amount exceeds a predefined threshold, the LPS invokes the Income Verification Service to verify the applicant’s income.\n5. The LPS evaluates all the data (credit and, if applicable, income) and makes a decision.\n6. The LPS notifies the customer of the loan approval or denial.",
        "output": "@startuml\ntitle Loan Application Processing\n\nactor \"Customer\" as C\nparticipant \"Loan Processing System\" as LPS\nparticipant \"Income Verification Service\" as IVS\nparticipant \"Credit Bureau\" as CB\n\nC -> LPS: Submit Loan Application\nactivate LPS\nLPS -> LPS: Validate Application Details\nLPS -> CB: Request Credit Check\nactivate CB\nCB --> LPS: Credit Score & Report\ndeactivate CB\n\nopt Loan Amount Exceeds Threshold\n    LPS -> IVS: Request Income Verification\n    activate IVS\n    IVS --> LPS: Income Verified / Income Details\n    deactivate IVS\nend\n\nLPS -> LPS: Evaluate Application (Credit & Income)\nLPS -> C: Notify Loan Approval/Denial\ndeactivate LPS\n@enduml"
    },
    {
        "file_name": "GPT_contain_opt_v5.txt",
        "input": "# Requirements: Smart Traffic Signal Control\n\n## Goal\nAllow pedestrians to safely cross intersections by activating the pedestrian crossing phase. Optionally, if the countdown timer feature is enabled, display a countdown timer to inform pedestrians when the crossing phase will begin.\n\n## Actors\n- **Pedestrian**: Presses the crossing button at the intersection.\n- **Traffic Signal Control System (TSCS)**: Manages the traffic signals and pedestrian crossing phases.\n- **Pedestrian Countdown Timer Service (PCTS)**: Optionally starts a countdown timer for the pedestrian crossing phase.\n\n## Preconditions\n- The traffic signal system is operational.\n- The optional countdown timer feature is configured (it may be enabled or disabled based on local policies or conditions).\n\n## Triggers\n- A pedestrian presses the crossing button.\n\n## Scenario\n1. The pedestrian presses the crossing button.\n2. The TSCS registers the request for a pedestrian crossing phase.\n3. If the countdown timer feature is enabled:\n   - The TSCS invokes the PCTS to start a countdown (e.g., 10 seconds) before the crossing phase begins.\n4. The TSCS activates the pedestrian crossing phase and displays the crossing signal, along with the countdown timer if available.\n5. The pedestrian receives the signal (and countdown information) and crosses safely.",
        "output": "@startuml\ntitle Smart Traffic Signal Control\nactor \"Pedestrian\" as P\nparticipant \"Traffic Signal Control System\" as TSCS\nparticipant \"Pedestrian Countdown Timer Service\" as PCTS\n\nP -> TSCS: Press Crossing Button\nactivate TSCS\nTSCS -> TSCS: Register Pedestrian Request\n\nopt Countdown Timer Feature Enabled\n    TSCS -> PCTS: Activate Countdown Timer\n    activate PCTS\n    PCTS --> TSCS: Countdown Started (e.g., 10 seconds)\n    deactivate PCTS\nend\n\nTSCS -> TSCS: Activate Pedestrian Crossing Phase\nTSCS -> P: Display Crossing Signal (with Countdown if available)\ndeactivate TSCS\n@enduml"
    },
    {
        "file_name": "GPT_contain_opt_v6.txt",
        "input": "# Requirements: Video Streaming\n\n## Goal\nAllow a customer to stream a movie and, if they are a premium subscriber, provide additional bonus content with the movie.\n\n## Actors\n- **Customer**: Selects a movie to play.\n- **Streaming Platform**: Manages video playback and bonus content for premium subscribers.\n- **Bonus Content Service**: Provides bonus content for premium subscribers.\n\n## Preconditions\n- The customer is subscribed to the streaming service.\n- The customer’s subscription plan (premium or not) is known.\n- The Bonus Content Service is operational.\n\n## Triggers\n- The customer selects a movie to stream.\n\n## Scenario\n1. The customer selects a movie to play on the Streaming Platform.\n2. The Streaming Platform initiates video playback.\n3. If the customer is a premium subscriber, the platform retrieves bonus content from the Bonus Content Service.\n4. The Streaming Platform delivers the video stream—integrating bonus content if available—to the customer.",
        "output": "@startuml\ntitle Video Streaming\n\nactor \"Customer\" as C\nparticipant \"Streaming Platform\" as SP\nparticipant \"Bonus Content Service\" as BCS\n\nC -> SP: Select Movie to Play\nactivate SP\nSP -> SP: Initiate Video Playback\n\nopt Customer is Premium Subscriber\n    SP -> BCS: Retrieve Bonus Content\n    activate BCS\n    BCS --> SP: Bonus Content Delivered\n    deactivate BCS\nend\n\nSP -> C: Deliver Video Stream (with bonus content if available)\ndeactivate SP\n@enduml"
    },
    {
        "file_name": "GPT_contain_par_v2.txt",
        "input": "# Requirements: Smart Home Intrusion Response\n\n## Goal\nWhen an intrusion is detected, the system should concurrently:\n- Notify the homeowner,\n- Activate security cameras,\n- Sound the home alarm, and\n- Alert local law enforcement.\n\n## Actors\n- **Intruder Sensor (IS):** Detects intrusions.\n- **Smart Home Hub (SHH):** Central controller that processes sensor events.\n- **Mobile Notification Service (MNS):** Sends notifications to the homeowner.\n- **Security Camera System (SCS):** Starts recording video.\n- **Alarm System (ASys):** Activates audible alarms.\n- **Police Alert System (PAS):** Sends alert to local law enforcement.\n\n## Preconditions\n- All IoT devices and services are online and communicating with the Smart Home Hub.\n- The system is configured with the appropriate contact and activation details.\n\n## Triggers\n- The Intruder Sensor detects an intrusion.\n\n## Scenario\n1. The Intruder Sensor notifies the Smart Home Hub of an intrusion.\n2. The Smart Home Hub analyzes the event and, in parallel:\n   - Sends a push notification via the **Mobile Notification Service**.\n   - Activates the **Security Camera System** to begin recording.\n   - Triggers the **Alarm System** to sound an alert.\n   - Sends an alert to the **Police Alert System**.\n3. Once all actions are complete, the Smart Home Hub confirms the incident response.",
        "output": "@startuml\ntitle Smart Home Intrusion Response\n\nactor \"Intruder Sensor\" as IS\nparticipant \"Smart Home Hub\" as SHH\nparticipant \"Mobile Notification Service\" as MNS\nparticipant \"Security Camera System\" as SCS\nparticipant \"Alarm System\" as ASys\nparticipant \"Police Alert System\" as PAS\n\nIS -> SHH: Intrusion Detected\nactivate SHH\n\npar Send Notification to Homeowner\n    SHH -> MNS: Send Push Notification\n    activate MNS\n    MNS --> SHH: Notification Sent\n    deactivate MNS\nelse Activate Security Cameras\n    SHH -> SCS: Start Recording\n    activate SCS\n    SCS --> SHH: Recording Started\n    deactivate SCS\nelse Activate Home Alarm\n    SHH -> ASys: Trigger Alarm\n    activate ASys\n    ASys --> SHH: Alarm Activated\n    deactivate ASys\nelse Alert Local Authorities\n    SHH -> PAS: Send Alert\n    activate PAS\n    PAS --> SHH: Alert Acknowledged\n    deactivate PAS\nend\n\nSHH -> IS: Confirm Incident Response\ndeactivate SHH\n@enduml"
    },
    {
        "file_name": "GPT_contain_par_v3.txt",
        "input": "# Requirements: Social Media Post Publishing\n\n## Goal\n\nAllow a user to publish a new post and concurrently update various system components (timeline, notifications, moderation, and analytics) to ensure timely and integrated content delivery.\n\n## Actors\n\n- **User:** Creates a new post.\n- **Social Media Platform (SMP):** Central system managing post publication.\n- **Timeline Service (TS):** Inserts the post into the user's timeline and feeds.\n- **Notification Service (NS):** Sends notifications to followers.\n- **Moderation Service (MS):** Reviews the post for compliance with community guidelines.\n- **Analytics Service (AS):** Logs the event for usage statistics.\n\n## Preconditions\n\n- The user is authenticated and active on the platform.\n- All the backend services (timeline, notification, moderation, and analytics) are operational.\n\n## Triggers\n\n- The user submits a new post.\n\n## Scenario\n\n1. The user submits a new post to the **Social Media Platform**.\n2. The **SMP** validates and saves the post.\n3. In parallel, the **SMP** initiates the following actions:\n   - **Timeline Update:** Inserts the post into the user’s timeline and friends’ feeds.\n   - **Notifications:** Sends push notifications to active followers.\n   - **Moderation:** Forwards the post to the **Moderation Service** for review.\n   - **Analytics Logging:** Records the post event in the **Analytics Service**.\n4. Once all parallel interactions complete, the **SMP** confirms that the post is published.",
        "output": "@startuml\ntitle Social Media Post Publishing\n\nactor \"User\" as U\nparticipant \"Social Media Platform\" as SMP\nparticipant \"Timeline Service\" as TS\nparticipant \"Notification Service\" as NS\nparticipant \"Moderation Service\" as MS\nparticipant \"Analytics Service\" as AS\n\nU -> SMP: Create New Post\nactivate SMP\nSMP -> SMP: Validate & Save Post\n\npar Update Timeline\n    SMP -> TS: Insert Post into Timeline\n    activate TS\n    TS --> SMP: Timeline Updated\n    deactivate TS\nelse Send Notifications\n    SMP -> NS: Notify Active Followers\n    activate NS\n    NS --> SMP: Notifications Sent\n    deactivate NS\nelse Moderate Content\n    SMP -> MS: Send Post for Moderation\n    activate MS\n    MS --> SMP: Moderation Complete\n    deactivate MS\nelse Log Analytics\n    SMP -> AS: Log Post Event\n    activate AS\n    AS --> SMP: Analytics Logged\n    deactivate AS\nend\n\nSMP -> U: Confirm Post Published\ndeactivate SMP\n@enduml"
    },
    {
        "file_name": "GPT_contain_par_v4.txt",
        "input": "# Smart Grid Outage Response\n\n## Goal\nEnsure rapid response to a grid outage by performing multiple actions to isolate the fault, notify maintenance and customers, and reroute power from backup sources.\n\n## Actors\n- **Grid Sensor (GS):** Detects an outage or fault in the grid.\n- **Grid Management System (GMS):** Central controller that receives outage alerts and coordinates responses.\n- **Switch Control System (SCS):** Reconfigures grid switches to isolate the fault.\n- **Field Maintenance Team (FMT):** Receives alerts and dispatches technicians.\n- **Customer Notification System (CNS):** Sends outage notifications to affected customers.\n- **Alternative Energy Controller (AEC):** Reroutes power from backup sources to maintain supply.\n\n## Preconditions\n- The grid sensor network is active and providing real-time data.\n- All control systems and communication channels are operational.\n\n## Triggers\n- An outage or fault is detected by the **Grid Sensor (GS)**.\n\n## Scenario\n1. The Grid Sensor detects an outage and notifies the Grid Management System.\n2. The GMS analyzes the event and, in parallel, initiates the following actions:\n   - **Fault Isolation:** Instructs the Switch Control System to reconfigure switches and isolate the fault.\n   - **Maintenance Alert:** Notifies the Field Maintenance Team to dispatch technicians.\n   - **Customer Notification:** Sends outage alerts to affected customers via the Customer Notification System.\n   - **Power Rerouting:** Instructs the Alternative Energy Controller to reroute power from backup sources.\n3. After all actions complete, the Grid Management System logs the outage event and continues to monitor grid stability.",
        "output": "@startuml\ntitle Smart Grid Outage Response\n\nactor \"Grid Sensor\" as GS\nparticipant \"Grid Management System\" as GMS\nparticipant \"Switch Control System\" as SCS\nparticipant \"Field Maintenance Team\" as FMT\nparticipant \"Customer Notification System\" as CNS\nparticipant \"Alternative Energy Controller\" as AEC\n\nGS -> GMS: Outage Detected\nactivate GMS\nGMS -> GMS: Analyze Outage Event\n\npar Isolate Fault\n    GMS -> SCS: Reconfigure Switches to Isolate Fault\n    activate SCS\n    SCS --> GMS: Fault Isolated\n    deactivate SCS\nelse Notify Maintenance\n    GMS -> FMT: Alert Outage - Dispatch Technicians\n    activate FMT\n    FMT --> GMS: Acknowledge Alert\n    deactivate FMT\nelse Notify Customers\n    GMS -> CNS: Send Outage Notifications\n    activate CNS\n    CNS --> GMS: Notifications Sent\n    deactivate CNS\nelse Reroute Power\n    GMS -> AEC: Reroute Power from Backup Sources\n    activate AEC\n    AEC --> GMS: Power Rerouted\n    deactivate AEC\nend\n\nGMS -> GMS: Log Outage Event & Monitor Stability\nGMS -> GS: Confirm Response Completion\ndeactivate GMS\n@enduml"
    },
    {
        "file_name": "GPT_contain_par_v5.txt",
        "input": "# Air Defense Threat Response with Multiple Countermeasures\n\n## Goal\nEnsure rapid response to an incoming air threat by simultaneously engaging multiple countermeasures to neutralize the threat.\n\n## Actors\n- **Radar System (RS):** Detects incoming threats.\n- **Air Defense Command Center (ADCC):** Analyzes threat data and coordinates the response.\n- **Interceptor Launch System (ILS):** Launches interceptor missiles to neutralize the threat.\n- **Electronic Warfare System (EWS):** Activates jamming to disrupt the threat’s guidance.\n- **Decoy Deployment System (DDS):** Deploys decoys to confuse the threat’s targeting.\n- **Pilot Notification System (PNS):** Alerts the pilot about the threat and countermeasures.\n\n## Preconditions\n- The radar and all countermeasure systems are operational.\n- The threat (e.g., an incoming missile) is detected by the Radar System.\n\n## Triggers\n- The Radar System detects an incoming threat and notifies the ADCC.\n\n## Scenario\n1. The Radar System detects an incoming threat and sends an alert to the ADCC.\n2. The ADCC analyzes the threat and, in parallel:\n   - Instructs the Interceptor Launch System to launch interceptor missiles.\n   - Activates the Electronic Warfare System to jam the threat’s guidance.\n   - Deploys decoys via the Decoy Deployment System to confuse the threat’s targeting.\n   - Notifies the Pilot Notification System about the threat and the ongoing countermeasures.\n3. After all parallel responses are executed, the ADCC logs the response and continues to monitor the threat.",
        "output": "@startuml\ntitle Air Defense Threat Response with Multiple Countermeasures\n\nactor \"Radar System\" as RS\nparticipant \"Air Defense Command Center\" as ADCC\nparticipant \"Interceptor Launch System\" as ILS\nparticipant \"Electronic Warfare System\" as EWS\nparticipant \"Decoy Deployment System\" as DDS\nparticipant \"Pilot Notification System\" as PNS\n\nRS -> ADCC: Threat Detected (Incoming Missile)\nactivate ADCC\nADCC -> ADCC: Analyze Threat\n\npar Launch Interceptors\n    ADCC -> ILS: Launch Interceptor Missiles\n    activate ILS\n    ILS --> ADCC: Interceptors Launched\n    deactivate ILS\nelse Jam Guidance\n    ADCC -> EWS: Initiate Electronic Jamming\n    activate EWS\n    EWS --> ADCC: Jamming Activated\n    deactivate EWS\nelse Deploy Decoys\n    ADCC -> DDS: Deploy Decoys\n    activate DDS\n    DDS --> ADCC: Decoys Deployed\n    deactivate DDS\nelse Notify Pilot\n    ADCC -> PNS: Alert Pilot: \"Threat Detected, Countermeasures Engaged\"\n    activate PNS\n    PNS --> ADCC: Pilot Notified\n    deactivate PNS\nend\n\nADCC -> ADCC: Log Response and Monitor Threat\ndeactivate ADCC\n@enduml"
    },
    {
        "file_name": "GPT_contain_par_v6.txt",
        "input": "# Requirements: Mobile Device Network Registration\n\n## Goal\nAllow a mobile device to register on the network while simultaneously performing several background tasks (authentication, location update, IP allocation, and billing update).\n\n## Actors\n- **Mobile Device (MD)**: Initiates the registration request.\n- **Mobile Switching Center (MSC)**: Processes the registration and coordinates parallel services.\n- **Location Update Server (LuS)**: Verifies the subscriber’s credentials.\n- **DHCP Server (DHCP)**: Allocates an IP address to the mobile device.\n- **Billing System (BillSys)**: Records the network event for billing purposes.\n\n## Preconditions\n- The mobile device is powered on and in a network coverage area.\n- All backend systems (authentication, location update, DHCP, and billing) are operational.\n\n## Triggers\n- The mobile device sends a registration request to the MSC.\n\n## Scenario\n1. The mobile device sends a registration request to the MSC.\n2. The MSC processes the registration and, in parallel, initiates:\n   - **Authentication**: Verifies the device credentials with the Location Update Server (LuS).\n   - **Location Update**: Updates the device’s location in the network.\n   - **IP Allocation**: Requests an IP address from the DHCP Server.\n   - **Billing Update**: Notifies the Billing System of the registration event.\n3. Once all parallel tasks complete, the MSC confirms the registration back to the mobile device.",
        "output": "@startuml\ntitle Mobile Device Network Registration\n\nactor \"Mobile Device\" as MD\nparticipant \"Mobile Switching Center\" as MSC\nparticipant \"Authentication Server\" as AuthS\nparticipant \"Location Update Server\" as LUS\nparticipant \"DHCP Server\" as DHCP\nparticipant \"Billing System\" as BillSys\n\nMD -> MSC: Send Registration Request\nactivate MSC\nMSC -> MSC: Process Registration Request\n\npar Authenticate Subscriber\n    MSC -> AuthS: Verify Credentials\n    activate AuthS\n    AuthS --> MSC: Authenticated\n    deactivate AuthS\nelse Update Location\n    MSC -> LUS: Update Location Info\n    activate LUS\n    LUS --> MSC: Location Updated\n    deactivate LUS\nelse Allocate IP Address\n    MSC -> DHCP: Request IP Address\n    activate DHCP\n    DHCP --> MSC: IP Address Assigned\n    deactivate DHCP\nelse Notify Billing\n    MSC -> BillSys: Record Registration Event\n    activate BillSys\n    BillSys --> MSC: Billing Record Updated\n    deactivate BillSys\nend\n\nMSC -> MD: Confirm Registration\ndeactivate MSC\n@enduml"
    }
]