[
    {
        "file_name": "simple_one.txt",
        "input": "# Requirements: User Login\n\n## Goal\nAllow a user to log into the system with email and password.\n\n## Actors\n- **User**\n- **Web System**\n\n## Preconditions\n- User must already have an account registered.\n\n## Triggers\n- User clicks the \"Login\" button or link.\n\n## Basic Scenario\n1. User clicks \"Login.\"\n2. Web System requests email and password.\n3. User provides credentials.\n4. Web System verifies credentials.\n5. Web System creates a session.\n6. User is shown the dashboard.",
        "output": "@startuml\ntitle User Login\n\nactor User\nparticipant \"Web System\" as System\n\nUser -> System: Click \"Login\"\nactivate System\n\nSystem -> User: Request email & password\nUser -> System: Provide credentials\n\nSystem -> System: Verify credentials\nSystem -> System: Create session\n\nSystem -> User: Display dashboard\ndeactivate System\n@enduml"
    },
    {
        "file_name": "GPT_contain_alt_v1.txt",
        "input": "# Requirements: Product Return and Refund\n\n## Goal\nAllow a customer to request a product return and manage different outcomes depending on the return policy, product condition, and timing.\n\n## Actors\n- **Customer (C)**: Initiates the return request.\n- **E-commerce System (ES)**: Manages the return process and checks policies.\n- **Warehouse (W)**: Receives the returned product if approved.\n- **Payment Gateway (PG)**: Processes refunds when required.\n\n## Preconditions\n- The customer has an order history in the system.\n- The product was purchased within some return window (e.g., 30 days), though this must be verified.\n- The warehouse is capable of receiving returns.\n\n## Triggers\n- The customer initiates a “Return Product” request through their order history page.\n\n## Basic Scenario - Eligible for Return\n1. The customer requests to return a product.\n2. The E-commerce System checks if the product is eligible for return (within the return window, correct order status, etc.).\n3. The E-commerce System prompts the customer to confirm the reason for the return.\n4. **If the reason is valid** (e.g., defective item):\n   - The system authorizes the return and sends a return shipping label to the customer.\n5. **If the reason is invalid** (e.g., “I changed my mind” after the return window):\n   - The system may still authorize the return but with a restocking fee.\n6. If a return is authorized, the customer ships the product back to the warehouse.\n7. Once the warehouse receives the item, the E-commerce System updates the order status.\n8. Based on the product condition:\n   - **Acceptable Condition:** A refund is issued through the Payment Gateway.\n   - **Damaged or Missing Parts:** The system may deny the refund or issue a partial refund.\n9. The E-commerce System notifies the customer of the final outcome (full refund, partial refund, or denial).\n\n## Alternative Flows A - Not Eligible for Return\n1. Same as Basic Scenario step 1. \n2. Same as Basic Scenario step 2.\n3. The system denies the return request, explaining the policy reason.\n4. The customer can contact support for further assistance or accept the denial.",
        "output": "@startuml\ntitle Product Return and Refund\n\nactor \"Customer\" as C\nparticipant \"E-commerce System\" as ES\nparticipant \"Warehouse\" as W\nparticipant \"Payment Gateway\" as PG\n\nC -> ES: Request Return for Product\nactivate ES\nES -> ES: Check Return Eligibility\n\nalt Eligible for Return\n  ES -> C: Prompt for return reason\n  alt Reason is valid (e.g., defective)\n    ES -> C: Authorize return, provide shipping label\n  else Reason is invalid or changed mind\n    ES -> C: Authorize return with restocking fee\n  end\n\n  C -> W: Ship product back\n  activate W\n  W -> ES: Notify product received\n  deactivate W\n\n  ES -> ES: Inspect product condition\n  alt Product in acceptable condition\n    ES -> PG: Issue Refund\n    activate PG\n    PG --> ES: Refund Confirmed\n    deactivate PG\n    ES -> C: Notify Full Refund\n  else Product damaged or incomplete\n    ES -> C: Partial refund or denial\n  end\n\nelse Not Eligible for Return\n  ES -> C: Return Request Denied\nend\n\ndeactivate ES\n@enduml"
    },
    {
        "file_name": "GPT_contain_interaction_v1.txt",
        "input": "# Requirements: Service Request\n\n## Goal\nAllow a customer to submit a service request after ensuring they are logged in by a login process.\n\n## Actors\n- **Customer**: Initiates the service request.\n- **Service Portal**: Manages the overall request flow.\n- **Authentication Service**: Handles the login process.\n- **Order Processing**: Handles order inquiries.\n- **Support Desk**: Handles support requests.\n\n## Preconditions\n- The customer may not yet be logged in when starting a service request.\n- The common login process is available for reuse.\n\n## Triggers\n- The customer submits a service request.\n\n## Basic Scenario\n1. The customer initiates a service request via the Service Portal.\n2. The Service Portal invokes the login process to ensure the customer is authenticated (Refer to Login Process).\n3. After successful login, the Service Portal routes the request to the appropriate handler:\n   - If it’s an order inquiry, the request goes to Order Processing.\n   - If it’s a support issue, the request goes to the Support Desk.\n4. The chosen system processes the request and returns a response to the customer.",
        "output": "@startuml\ntitle Service Request\n\nactor Customer\nparticipant \"Service Portal\" as SP\nparticipant \"Auth Service\" as AS\nparticipant \"Order Processing\" as OP\nparticipant \"Support Desk\" as SD\n\nCustomer -> SP: Initiate Service Request\nactivate SP\n\n' Reuse the common login process as an embedded interaction:\nref over Customer, AS \n  Common Login Process\nend ref\n\nalt Request is for Order Inquiry\n  SP -> OP: Process Order Inquiry\n  OP --> SP: Return Order Details\nelse Request is for Support\n  SP -> SD: Process Support Request\n  SD --> SP: Return Ticket Confirmation\nend\n\nSP --> Customer: Return Service Response\ndeactivate SP\n@enduml"
    },
    {
        "file_name": "GPT_contain_loop_v1.txt",
        "input": "# Requirements: Generate Order Summaries\n\n## Goal\nAllow a user to request an order summary that processes multiple items in their cart sequentially.\n\n## Actors\n- **User** – Initiates the summary request.\n- **E-Commerce System** – Retrieves cart details and processes each item.\n- **Inventory Service** – Provides pricing and availability details for each item.\n\n## Preconditions\n- The user must have an active cart.\n- The E-Commerce System and Inventory Service are both available.\n\n## Triggers\n- The user clicks the “View Order Summary” button.\n\n## Basic Scenario\n1. The user requests an order summary from the E-Commerce System.\n2. The E-Commerce System retrieves the list of items in the user’s cart.\n3. The system enters a loop, iterating over each cart item:\n   - For each item, it queries the Inventory Service for up-to-date pricing and availability.\n   - The Inventory Service returns the item details.\n4. After all items are processed, the E-Commerce System calculates the total cost and applicable taxes.\n5. The system returns the completed order summary to the user.\n\n## Alternative Scenario\n- If the Inventory Service fails or times out for an item, the E-Commerce System logs the error, skips that item, and continues with the next item in the loop.",
        "output": "@startuml\ntitle Generate Order Summaries (Loop + Alternative Scenario)\n\nactor User\nparticipant \"E-Commerce System\" as ECS\nparticipant \"Inventory Service\" as IS\n\nUser -> ECS: Click \"View Order Summary\"\nactivate ECS\n\nECS -> ECS: Retrieve cart items\n\nloop For each Item in Cart\n    ECS -> IS: Request Item Details\n    activate IS\n    alt Inventory Service Succeeds\n        IS --> ECS: Return Pricing & Availability\n    else Inventory Service Fails or Times Out\n        ECS -> ECS: Log error (skip item)\n    end\n    deactivate IS\nend\n\nECS -> ECS: Calculate total cost & taxes\nECS --> User: Display Order Summary\ndeactivate ECS\n@enduml"
    },
    {
        "file_name": "GPT_contain_opt_v1.txt",
        "input": "# Requirements: Order Shipment\n\n## Goal\nProcess an order shipment and, if the customer opted for shipment insurance, process the insurance and send policy details.\n\n## Actors\n- **Customer**: Places the order and may opt in for shipment insurance.\n- **Logistics Management System (LMS)**: Manages order shipments and coordinates optional insurance processing.\n- **Shipping Carrier (SC)**: Handles pickup and delivery of the order.\n- **Insurance Service (IS)**: Processes shipment insurance if requested.\n\n## Preconditions\n- The order is ready for shipment.\n- The customer has either opted for shipment insurance or not.\n- LMS is integrated with both the Shipping Carrier and the Insurance Service.\n\n## Triggers\n- The order is finalized and ready to be shipped.\n\n## Scenario\n1. The LMS schedules the order pickup and delivery with the Shipping Carrier.\n2. The Shipping Carrier confirms the shipment.\n3. If insurance was selected:\n   - The LMS contacts the Insurance Service to process shipment insurance.\n   - Once processed, the LMS sends the insurance policy details to the customer.\n4. The LMS notifies the customer that the order has been shipped.",
        "output": "@startuml\ntitle Order Shipment\n\nactor \"Customer\" as C\nparticipant \"Logistics Management System\" as LMS\nparticipant \"Shipping Carrier\" as SC\nparticipant \"Insurance Service\" as IS\n\nLMS -> SC: Schedule Pickup and Delivery\nactivate LMS\nactivate SC\nSC --> LMS: Shipment Confirmed\ndeactivate SC\n\nopt Customer opted for Insurance\n  LMS -> IS: Process Shipment Insurance\n  activate IS\n  IS --> LMS: Insurance Processed\n  deactivate IS\n  LMS -> C: Send Insurance Policy Details\nend\n\nLMS -> C: Notify Order Shipped\ndeactivate LMS\n@enduml"
    },
    {
        "file_name": "GPT_contain_par_v1.txt",
        "input": "# Requirements: Self-Driving Car Emergency Response\n\n## Goal\nEnsure that when a self-driving car detects an obstacle, it can simultaneously engage emergency braking and compute a new route to safely navigate around the obstacle.\n\n## Actors\n- **Autonomous Vehicle (AV):** Detects obstacles and initiates the emergency response.\n- **Vehicle Control Unit (VCU):** Analyzes the situation and coordinates safety and navigation actions.\n- **Safety System (SS):** Responsible for engaging emergency braking.\n- **Navigation System (NS):** Calculates an alternative route.\n\n## Preconditions\n- The autonomous vehicle is operating and its sensors detect an obstacle.\n- The Safety System and Navigation System are active and responsive.\n\n## Triggers\n- An obstacle is detected by the vehicle’s sensor suite.\n\n## Scenario\n1. The Autonomous Vehicle detects an obstacle and notifies the VCU.\n2. The VCU analyzes the situation and simultaneously initiates two parallel interactions:\n   - **Interaction 1:** Sends a command to the Safety System to engage emergency braking.\n   - **Interaction 2:** Requests a new route from the Navigation System.\n3. The Safety System engages emergency braking, and the Navigation System computes a new route concurrently.\n4. Once both actions complete, the VCU updates the vehicle’s status (indicating braking is active and a new route is available) and logs the event.",
        "output": "@startuml\ntitle Self-Driving Car Emergency Respons\nactor \"Autonomous Vehicle\" as AV\nparticipant \"Vehicle Control Unit\" as VCU\nparticipant \"Safety System\" as SS\nparticipant \"Navigation System\" as NS\n\nAV -> VCU: Detect Obstacle\nactivate VCU\nVCU -> VCU: Analyze Situation\n\npar Emergency Braking\n    VCU -> SS: Initiate Emergency Braking\n    activate SS\n    SS --> VCU: Braking Engaged\n    deactivate SS\nelse Rerouting\n    VCU -> NS: Request New Route\n    activate NS\n    NS --> VCU: New Route Calculated\n    deactivate NS\nend\n\nVCU -> AV: Update Status (Braking & New Route)\nVCU -> VCU: Log Emergency Event\ndeactivate VCU\n@enduml"
    }
]